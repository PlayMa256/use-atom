{"version":3,"file":"index.esm.js","sources":["../src/Provider.tsx","../src/createAtom.ts","../src/deriveAtom.ts","../src/useAtom.ts","../src/useAtomValue.ts","../src/useAtomUpdate.ts","../src/compat/atom.ts","../src/compat/selector.ts"],"sourcesContent":["import React, { Dispatch, SetStateAction, useReducer } from 'react';\nimport { createContext } from 'use-context-selector';\n\nimport { Atom, WritableAtom } from './createAtom';\n\nconst warningObject = new Proxy({}, {\n  get() { throw new Error('Please use <Provider>'); },\n  apply() { throw new Error('Please use <Provider>'); },\n});\n\nexport type Suspendable<Value> = {\n  promise: Promise<void> | null;\n  value: Value;\n};\n\ntype State = {\n  values: Map<Atom<unknown>, Suspendable<unknown>>;\n  dependents: Map<Atom<unknown>, Set<Atom<unknown>>>;\n};\n\nconst initialState: State = {\n  values: new Map(),\n  dependents: new Map(),\n};\n\ntype Action =\n  | {\n    type: 'INIT_ATOM';\n    atom: Atom<unknown>;\n  }\n  | {\n    type: 'UPDATE_VALUE';\n    atom: WritableAtom<unknown>;\n    update: SetStateAction<unknown>;\n  }\n  | {\n    type: 'SET_VALUE';\n    atom: WritableAtom<unknown>;\n    value: unknown;\n  }\n  | {\n    type: 'ADD_DEPENDENTS';\n    deps: { atom: Atom<unknown>; dependent: Atom<unknown> }[];\n  }\n  | {\n    type: 'UPDATE_DEPENDENTS';\n    atom: Atom<unknown>;\n  };\n\nexport const DispatchContext = createContext(warningObject as Dispatch<Action>);\nexport const StateContext = createContext(warningObject as State);\n\nexport const Provider: React.FC = ({ children }) => {\n  const [state, dispatch] = useReducer((prevState: State, action: Action) => {\n    const currState = { ...prevState };\n    let dirty = false;\n    let inReducer = true;\n    const addDependents = (\n      deps: { atom: Atom<unknown>; dependent: Atom<unknown> }[],\n    ) => {\n      deps.forEach(({ atom, dependent }) => {\n        const currSet = currState.dependents.get(atom) || new Set();\n        if (currSet.has(dependent)) {\n          return;\n        }\n        const dependents = new Map(currState.dependents).set(atom, currSet.add(dependent));\n        currState.dependents = dependents;\n        dirty = true;\n      });\n    };\n    const getSuspendable = (atom: Atom<unknown>) => {\n      // XXX too complicated\n      const deps: { atom: Atom<unknown>; dependent: Atom<unknown> }[] = [];\n      const nextValue = atom.get({\n        get: (a: Atom<unknown>) => {\n          if (a !== atom) {\n            deps.push({ atom: a, dependent: atom });\n          }\n          const s = currState.values.get(a);\n          return s ? s.value : a.default;\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } as any);\n      let suspendable: Suspendable<unknown>;\n      if (nextValue instanceof Promise) {\n        const currSuspendable = currState.values.get(atom);\n        const currValue = currSuspendable ? currSuspendable.value : atom.default;\n        suspendable = {\n          promise: nextValue.then(async (v) => {\n            dispatch({ type: 'ADD_DEPENDENTS', deps });\n            const promises = deps\n              .map((dep) => currState.values.get(dep.atom)?.promise)\n              .filter((x) => !!x);\n            if (promises.length > 0) {\n              await Promise.all(promises).then(async () => {\n                const nextSuspendable = getSuspendable(atom);\n                suspendable.value = nextSuspendable.value;\n                await nextSuspendable.promise;\n              });\n            } else {\n              suspendable.promise = null;\n              suspendable.value = v;\n            }\n          }),\n          value: currValue,\n        };\n      } else {\n        addDependents(deps);\n        const promises = deps\n          .map((dep) => currState.values.get(dep.atom)?.promise)\n          .filter((x) => !!x);\n        if (promises.length > 0) {\n          suspendable = {\n            promise: Promise.all(promises).then(async () => {\n              const nextSuspendable = getSuspendable(atom);\n              suspendable.value = nextSuspendable.value;\n              await nextSuspendable.promise;\n            }),\n            value: nextValue,\n          };\n        } else {\n          suspendable = {\n            promise: null,\n            value: nextValue,\n          };\n        }\n      }\n      return suspendable;\n    };\n    const initAtom = (atom: Atom<unknown>) => {\n      if (currState.values.has(atom)) {\n        return;\n      }\n      const suspendable = getSuspendable(atom);\n      const values = new Map(currState.values).set(atom, suspendable);\n      currState.values = values;\n      dirty = true;\n    };\n    const updateDependents = (atom: Atom<unknown>) => {\n      const currSet = currState.dependents.get(atom) || new Set();\n      if (currSet.size === 0) {\n        return;\n      }\n      const values = new Map(currState.values);\n      currSet.forEach((dependent) => {\n        const suspendable = getSuspendable(dependent);\n        if (suspendable.promise) {\n          suspendable.promise.then(() => {\n            dispatch({ type: 'UPDATE_DEPENDENTS', atom: dependent });\n          });\n        } else {\n          updateDependents(dependent);\n        }\n        values.set(dependent, suspendable);\n      });\n      currState.values = values;\n      dirty = true;\n    };\n    const setValue = (atom: WritableAtom<unknown>, value: unknown) => {\n      const currSuspendable = currState.values.get(atom);\n      const currValue = currSuspendable ? currSuspendable.value : atom.default;\n      if (currValue === value) {\n        return;\n      }\n      if (!inReducer) {\n        // schedule next render\n        dispatch({ type: 'SET_VALUE', atom, value });\n        return;\n      }\n      currState.values = new Map(currState.values).set(atom, { promise: null, value });\n      const promise = atom.set({\n        get: (a: Atom<unknown>) => {\n          const s = currState.values.get(a);\n          return s ? s.value : a.default;\n        },\n        set: (a: WritableAtom<unknown>, v: unknown) => {\n          if (a !== atom) {\n            // XXX we can't make this suspendable\n            // because we don't know which atom will be updated in advance.\n            setValue(a, v);\n          }\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } as any, value);\n      let suspendable: Suspendable<unknown>;\n      if (promise instanceof Promise) {\n        suspendable = {\n          promise: promise.then(async () => {\n            const nextSuspendable = getSuspendable(atom);\n            suspendable.value = nextSuspendable.value;\n            await nextSuspendable.promise;\n            suspendable.value = nextSuspendable.value;\n          }),\n          value: currValue,\n        };\n      } else {\n        suspendable = getSuspendable(atom);\n      }\n      const values = new Map(currState.values).set(atom, suspendable);\n      currState.values = values;\n      dirty = true;\n      updateDependents(atom);\n    };\n    const updateValue = (atom: WritableAtom<unknown>, update: SetStateAction<unknown>) => {\n      const currSuspendable = currState.values.get(atom);\n      const currValue = currSuspendable ? currSuspendable.value : atom.default;\n      const nextValue = typeof update === 'function' ? update(currValue) : update;\n      setValue(atom, nextValue);\n    };\n    switch (action.type) {\n      case 'INIT_ATOM':\n        initAtom(action.atom);\n        break;\n      case 'UPDATE_DEPENDENTS':\n        updateDependents(action.atom);\n        break;\n      case 'SET_VALUE':\n        setValue(action.atom, action.value);\n        break;\n      case 'UPDATE_VALUE':\n        updateValue(action.atom, action.update);\n        break;\n      case 'ADD_DEPENDENTS':\n        addDependents(action.deps);\n        break;\n      default:\n        throw new Error('unexpected action type');\n    }\n    inReducer = false;\n    if (dirty) {\n      return currState;\n    }\n    return prevState;\n  }, initialState);\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state}>\n        {children}\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n};\n","export type Atom<Value> = {\n  default: Value;\n  get: (arg: {\n    get: <V>(a: Atom<V>) => V;\n  }) => Value | Promise<Value>;\n}\n\nexport type WritableAtom<Value> = Atom<Value> & {\n  set: (arg: {\n    get: <V>(a: Atom<V>) => V;\n    set: <V>(a: WritableAtom<V>, v: V) => void;\n  }, newValue: Value) => void | Promise<void>;\n}\n\nexport function createAtom<Value>(\n  options: { default: Value },\n): WritableAtom<Value> {\n  const atom: WritableAtom<Value> = {\n    ...options,\n    get: (arg) => arg.get(atom),\n    set: (arg, newValue) => arg.set(atom, newValue),\n  };\n  return atom;\n}\n","import { Atom, WritableAtom } from './createAtom';\n\nexport function deriveAtom<Value>(\n  options: {\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n    set: (arg: {\n      get: <V>(a: Atom<V>) => V;\n      set: <V>(a: WritableAtom<V>, v: V) => void;\n    }, newValue: Value) => void | Promise<void>;\n  },\n): WritableAtom<Value | null>;\n\nexport function deriveAtom<Value>(\n  options: {\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n  },\n): Atom<Value | null>;\n\nexport function deriveAtom<Value>(\n  options: {\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n    set?: (arg: {\n      get: <V>(a: Atom<V>) => V;\n      set: <V>(a: WritableAtom<V>, v: V) => void;\n    }, newValue: Value) => void | Promise<void>;\n  },\n) {\n  return {\n    ...options,\n    default: null,\n  };\n}\n","import {\n  Dispatch,\n  SetStateAction,\n  useCallback,\n  useEffect,\n} from 'react';\nimport { useContext, useContextSelector } from 'use-context-selector';\n\nimport { StateContext, DispatchContext, Suspendable } from './Provider';\nimport { Atom, WritableAtom } from './createAtom';\n\nconst isWritable = (\n  atom: Atom<unknown> | WritableAtom<unknown>,\n): atom is WritableAtom<unknown> => !!(atom as WritableAtom<unknown>).set;\n\nexport function useAtom<Value>(atom: WritableAtom<Value>): [Value, Dispatch<SetStateAction<Value>>]\nexport function useAtom<Value>(atom: Atom<Value>): [Value, never]\n\nexport function useAtom<Value>(atom: Atom<Value> | WritableAtom<Value>) {\n  const dispatch = useContext(DispatchContext);\n  const suspendable = useContextSelector(StateContext, useCallback((state) => (\n    state.values.get(atom) as Suspendable<Value> | undefined\n  ), [atom]));\n  const setAtomState = useCallback((update: SetStateAction<Value>) => {\n    if (isWritable(atom)) {\n      dispatch({ type: 'UPDATE_VALUE', atom, update });\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [atom, dispatch]);\n  useEffect(() => {\n    dispatch({ type: 'INIT_ATOM', atom });\n  }, [dispatch, atom]);\n  if (suspendable && suspendable.promise) {\n    throw suspendable.promise;\n  }\n  return [\n    suspendable === undefined ? atom.default : suspendable.value,\n    setAtomState,\n  ];\n}\n","import { useCallback, useEffect } from 'react';\nimport { useContext, useContextSelector } from 'use-context-selector';\n\nimport { StateContext, DispatchContext, Suspendable } from './Provider';\nimport { Atom } from './createAtom';\n\nexport function useAtomValue<Value>(atom: Atom<Value>) {\n  const dispatch = useContext(DispatchContext);\n  const suspendable = useContextSelector(StateContext, useCallback((state) => (\n    state.values.get(atom) as Suspendable<Value> | undefined\n  ), [atom]));\n  useEffect(() => {\n    dispatch({ type: 'INIT_ATOM', atom });\n  }, [dispatch, atom]);\n  if (suspendable && suspendable.promise) {\n    throw suspendable.promise;\n  }\n  return suspendable === undefined ? atom.default : suspendable.value;\n}\n","import { SetStateAction, useCallback, useEffect } from 'react';\nimport { useContext } from 'use-context-selector';\nimport { DispatchContext } from './Provider';\nimport { WritableAtom } from './createAtom';\n\nexport function useAtomUpdate<Value>(atom: WritableAtom<Value>) {\n  const dispatch = useContext(DispatchContext);\n  const setAtomState = useCallback((update: SetStateAction<Value>) => {\n    dispatch({\n      type: 'UPDATE_VALUE',\n      atom: atom as WritableAtom<unknown>,\n      update,\n    });\n  }, [atom, dispatch]);\n  useEffect(() => {\n    dispatch({ type: 'INIT_ATOM', atom });\n  }, [dispatch, atom]);\n  return setAtomState;\n}\n","import { createAtom, WritableAtom } from '../createAtom';\n\nexport function atom<Value>(\n  options: { key: string; default: Value },\n) {\n  return createAtom(options) as WritableAtom<Value> & { key: string };\n}\n","import { Atom, WritableAtom } from '../createAtom';\nimport { deriveAtom } from '../deriveAtom';\n\nexport function selector<Value>(\n  options: {\n    key: string;\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n    set: (arg: {\n      get: <V>(a: Atom<V>) => V;\n      set: <V>(a: WritableAtom<V>, v: V) => void;\n    }, newValue: Value) => void | Promise<void>;\n  },\n): WritableAtom<Value | null>;\n\nexport function selector<Value>(\n  options: {\n    key: string;\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n  },\n): Atom<Value | null>;\n\nexport function selector(options: unknown) {\n  return deriveAtom(options as Parameters<typeof deriveAtom>[0]);\n}\n"],"names":["warningObject","Proxy","get","Error","apply","initialState","values","Map","dependents","DispatchContext","createContext","StateContext","Provider","children","useReducer","prevState","action","currState","dirty","inReducer","addDependents","deps","forEach","atom","dependent","currSet","Set","has","set","add","getSuspendable","suspendable","nextValue","a","push","s","value","Promise","currSuspendable","currValue","promise","then","v","dispatch","type","promises","map","dep","_currState$values$get","filter","x","length","all","nextSuspendable","_currState$values$get2","updateDependents","size","setValue","initAtom","update","updateValue","React","createAtom","options","arg","newValue","deriveAtom","default","useAtom","useContext","useContextSelector","useCallback","state","setAtomState","isWritable","useEffect","undefined","useAtomValue","useAtomUpdate","selector"],"mappings":"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"}