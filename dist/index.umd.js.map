{"version":3,"file":"index.umd.js","sources":["../src/Provider.tsx","../src/createAtom.ts","../src/deriveAtom.ts","../src/useAtom.ts","../src/useAtomValue.ts","../src/useAtomUpdate.ts","../src/compat/atom.ts","../src/compat/selector.ts"],"sourcesContent":["import React, { Dispatch, SetStateAction, useReducer } from 'react';\nimport { createContext } from 'use-context-selector';\n\nimport { Atom, WritableAtom } from './createAtom';\n\nconst warningObject = new Proxy({}, {\n  get() { throw new Error('Please use <Provider>'); },\n  apply() { throw new Error('Please use <Provider>'); },\n});\n\nexport type Suspendable<Value> = {\n  promise: Promise<void> | null;\n  value: Value;\n};\n\ntype State = {\n  values: Map<Atom<unknown>, Suspendable<unknown>>;\n  dependents: Map<Atom<unknown>, Set<Atom<unknown>>>;\n};\n\nconst initialState: State = {\n  values: new Map(),\n  dependents: new Map(),\n};\n\ntype Action =\n  | {\n    type: 'INIT_ATOM';\n    atom: Atom<unknown>;\n  }\n  | {\n    type: 'UPDATE_VALUE';\n    atom: WritableAtom<unknown>;\n    update: SetStateAction<unknown>;\n  }\n  | {\n    type: 'SET_VALUE';\n    atom: WritableAtom<unknown>;\n    value: unknown;\n  }\n  | {\n    type: 'ADD_DEPENDENTS';\n    deps: { atom: Atom<unknown>; dependent: Atom<unknown> }[];\n  }\n  | {\n    type: 'UPDATE_DEPENDENTS';\n    atom: Atom<unknown>;\n  };\n\nexport const DispatchContext = createContext(warningObject as Dispatch<Action>);\nexport const StateContext = createContext(warningObject as State);\n\nexport const Provider: React.FC = ({ children }) => {\n  const [state, dispatch] = useReducer((prevState: State, action: Action) => {\n    const currState = { ...prevState };\n    let dirty = false;\n    let inReducer = true;\n    const addDependents = (\n      deps: { atom: Atom<unknown>; dependent: Atom<unknown> }[],\n    ) => {\n      deps.forEach(({ atom, dependent }) => {\n        const currSet = currState.dependents.get(atom) || new Set();\n        if (currSet.has(dependent)) {\n          return;\n        }\n        const dependents = new Map(currState.dependents).set(atom, currSet.add(dependent));\n        currState.dependents = dependents;\n        dirty = true;\n      });\n    };\n    const getSuspendable = (atom: Atom<unknown>) => {\n      // XXX too complicated\n      const deps: { atom: Atom<unknown>; dependent: Atom<unknown> }[] = [];\n      const nextValue = atom.get({\n        get: (a: Atom<unknown>) => {\n          if (a !== atom) {\n            deps.push({ atom: a, dependent: atom });\n          }\n          const s = currState.values.get(a);\n          return s ? s.value : a.default;\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } as any);\n      let suspendable: Suspendable<unknown>;\n      if (nextValue instanceof Promise) {\n        const currSuspendable = currState.values.get(atom);\n        const currValue = currSuspendable ? currSuspendable.value : atom.default;\n        suspendable = {\n          promise: nextValue.then(async (v) => {\n            dispatch({ type: 'ADD_DEPENDENTS', deps });\n            const promises = deps\n              .map((dep) => currState.values.get(dep.atom)?.promise)\n              .filter((x) => !!x);\n            if (promises.length > 0) {\n              await Promise.all(promises).then(async () => {\n                const nextSuspendable = getSuspendable(atom);\n                suspendable.value = nextSuspendable.value;\n                await nextSuspendable.promise;\n              });\n            } else {\n              suspendable.promise = null;\n              suspendable.value = v;\n            }\n          }),\n          value: currValue,\n        };\n      } else {\n        addDependents(deps);\n        const promises = deps\n          .map((dep) => currState.values.get(dep.atom)?.promise)\n          .filter((x) => !!x);\n        if (promises.length > 0) {\n          suspendable = {\n            promise: Promise.all(promises).then(async () => {\n              const nextSuspendable = getSuspendable(atom);\n              suspendable.value = nextSuspendable.value;\n              await nextSuspendable.promise;\n            }),\n            value: nextValue,\n          };\n        } else {\n          suspendable = {\n            promise: null,\n            value: nextValue,\n          };\n        }\n      }\n      return suspendable;\n    };\n    const initAtom = (atom: Atom<unknown>) => {\n      if (currState.values.has(atom)) {\n        return;\n      }\n      const suspendable = getSuspendable(atom);\n      const values = new Map(currState.values).set(atom, suspendable);\n      currState.values = values;\n      dirty = true;\n    };\n    const updateDependents = (atom: Atom<unknown>) => {\n      const currSet = currState.dependents.get(atom) || new Set();\n      if (currSet.size === 0) {\n        return;\n      }\n      const values = new Map(currState.values);\n      currSet.forEach((dependent) => {\n        const suspendable = getSuspendable(dependent);\n        if (suspendable.promise) {\n          suspendable.promise.then(() => {\n            dispatch({ type: 'UPDATE_DEPENDENTS', atom: dependent });\n          });\n        } else {\n          updateDependents(dependent);\n        }\n        values.set(dependent, suspendable);\n      });\n      currState.values = values;\n      dirty = true;\n    };\n    const setValue = (atom: WritableAtom<unknown>, value: unknown) => {\n      const currSuspendable = currState.values.get(atom);\n      const currValue = currSuspendable ? currSuspendable.value : atom.default;\n      if (currValue === value) {\n        return;\n      }\n      if (!inReducer) {\n        // schedule next render\n        dispatch({ type: 'SET_VALUE', atom, value });\n        return;\n      }\n      currState.values = new Map(currState.values).set(atom, { promise: null, value });\n      const promise = atom.set({\n        get: (a: Atom<unknown>) => {\n          const s = currState.values.get(a);\n          return s ? s.value : a.default;\n        },\n        set: (a: WritableAtom<unknown>, v: unknown) => {\n          if (a !== atom) {\n            // XXX we can't make this suspendable\n            // because we don't know which atom will be updated in advance.\n            setValue(a, v);\n          }\n        },\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } as any, value);\n      let suspendable: Suspendable<unknown>;\n      if (promise instanceof Promise) {\n        suspendable = {\n          promise: promise.then(async () => {\n            const nextSuspendable = getSuspendable(atom);\n            suspendable.value = nextSuspendable.value;\n            await nextSuspendable.promise;\n            suspendable.value = nextSuspendable.value;\n          }),\n          value: currValue,\n        };\n      } else {\n        suspendable = getSuspendable(atom);\n      }\n      const values = new Map(currState.values).set(atom, suspendable);\n      currState.values = values;\n      dirty = true;\n      updateDependents(atom);\n    };\n    const updateValue = (atom: WritableAtom<unknown>, update: SetStateAction<unknown>) => {\n      const currSuspendable = currState.values.get(atom);\n      const currValue = currSuspendable ? currSuspendable.value : atom.default;\n      const nextValue = typeof update === 'function' ? update(currValue) : update;\n      setValue(atom, nextValue);\n    };\n    switch (action.type) {\n      case 'INIT_ATOM':\n        initAtom(action.atom);\n        break;\n      case 'UPDATE_DEPENDENTS':\n        updateDependents(action.atom);\n        break;\n      case 'SET_VALUE':\n        setValue(action.atom, action.value);\n        break;\n      case 'UPDATE_VALUE':\n        updateValue(action.atom, action.update);\n        break;\n      case 'ADD_DEPENDENTS':\n        addDependents(action.deps);\n        break;\n      default:\n        throw new Error('unexpected action type');\n    }\n    inReducer = false;\n    if (dirty) {\n      return currState;\n    }\n    return prevState;\n  }, initialState);\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state}>\n        {children}\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n};\n","export type Atom<Value> = {\n  default: Value;\n  get: (arg: {\n    get: <V>(a: Atom<V>) => V;\n  }) => Value | Promise<Value>;\n}\n\nexport type WritableAtom<Value> = Atom<Value> & {\n  set: (arg: {\n    get: <V>(a: Atom<V>) => V;\n    set: <V>(a: WritableAtom<V>, v: V) => void;\n  }, newValue: Value) => void | Promise<void>;\n}\n\nexport function createAtom<Value>(\n  options: { default: Value },\n): WritableAtom<Value> {\n  const atom: WritableAtom<Value> = {\n    ...options,\n    get: (arg) => arg.get(atom),\n    set: (arg, newValue) => arg.set(atom, newValue),\n  };\n  return atom;\n}\n","import { Atom, WritableAtom } from './createAtom';\n\nexport function deriveAtom<Value>(\n  options: {\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n    set: (arg: {\n      get: <V>(a: Atom<V>) => V;\n      set: <V>(a: WritableAtom<V>, v: V) => void;\n    }, newValue: Value) => void | Promise<void>;\n  },\n): WritableAtom<Value | null>;\n\nexport function deriveAtom<Value>(\n  options: {\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n  },\n): Atom<Value | null>;\n\nexport function deriveAtom<Value>(\n  options: {\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n    set?: (arg: {\n      get: <V>(a: Atom<V>) => V;\n      set: <V>(a: WritableAtom<V>, v: V) => void;\n    }, newValue: Value) => void | Promise<void>;\n  },\n) {\n  return {\n    ...options,\n    default: null,\n  };\n}\n","import {\n  Dispatch,\n  SetStateAction,\n  useCallback,\n  useEffect,\n} from 'react';\nimport { useContext, useContextSelector } from 'use-context-selector';\n\nimport { StateContext, DispatchContext, Suspendable } from './Provider';\nimport { Atom, WritableAtom } from './createAtom';\n\nconst isWritable = (\n  atom: Atom<unknown> | WritableAtom<unknown>,\n): atom is WritableAtom<unknown> => !!(atom as WritableAtom<unknown>).set;\n\nexport function useAtom<Value>(atom: WritableAtom<Value>): [Value, Dispatch<SetStateAction<Value>>]\nexport function useAtom<Value>(atom: Atom<Value>): [Value, never]\n\nexport function useAtom<Value>(atom: Atom<Value> | WritableAtom<Value>) {\n  const dispatch = useContext(DispatchContext);\n  const suspendable = useContextSelector(StateContext, useCallback((state) => (\n    state.values.get(atom) as Suspendable<Value> | undefined\n  ), [atom]));\n  const setAtomState = useCallback((update: SetStateAction<Value>) => {\n    if (isWritable(atom)) {\n      dispatch({ type: 'UPDATE_VALUE', atom, update });\n    } else {\n      throw new Error('not writable atom');\n    }\n  }, [atom, dispatch]);\n  useEffect(() => {\n    dispatch({ type: 'INIT_ATOM', atom });\n  }, [dispatch, atom]);\n  if (suspendable && suspendable.promise) {\n    throw suspendable.promise;\n  }\n  return [\n    suspendable === undefined ? atom.default : suspendable.value,\n    setAtomState,\n  ];\n}\n","import { useCallback, useEffect } from 'react';\nimport { useContext, useContextSelector } from 'use-context-selector';\n\nimport { StateContext, DispatchContext, Suspendable } from './Provider';\nimport { Atom } from './createAtom';\n\nexport function useAtomValue<Value>(atom: Atom<Value>) {\n  const dispatch = useContext(DispatchContext);\n  const suspendable = useContextSelector(StateContext, useCallback((state) => (\n    state.values.get(atom) as Suspendable<Value> | undefined\n  ), [atom]));\n  useEffect(() => {\n    dispatch({ type: 'INIT_ATOM', atom });\n  }, [dispatch, atom]);\n  if (suspendable && suspendable.promise) {\n    throw suspendable.promise;\n  }\n  return suspendable === undefined ? atom.default : suspendable.value;\n}\n","import { SetStateAction, useCallback, useEffect } from 'react';\nimport { useContext } from 'use-context-selector';\nimport { DispatchContext } from './Provider';\nimport { WritableAtom } from './createAtom';\n\nexport function useAtomUpdate<Value>(atom: WritableAtom<Value>) {\n  const dispatch = useContext(DispatchContext);\n  const setAtomState = useCallback((update: SetStateAction<Value>) => {\n    dispatch({\n      type: 'UPDATE_VALUE',\n      atom: atom as WritableAtom<unknown>,\n      update,\n    });\n  }, [atom, dispatch]);\n  useEffect(() => {\n    dispatch({ type: 'INIT_ATOM', atom });\n  }, [dispatch, atom]);\n  return setAtomState;\n}\n","import { createAtom, WritableAtom } from '../createAtom';\n\nexport function atom<Value>(\n  options: { key: string; default: Value },\n) {\n  return createAtom(options) as WritableAtom<Value> & { key: string };\n}\n","import { Atom, WritableAtom } from '../createAtom';\nimport { deriveAtom } from '../deriveAtom';\n\nexport function selector<Value>(\n  options: {\n    key: string;\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n    set: (arg: {\n      get: <V>(a: Atom<V>) => V;\n      set: <V>(a: WritableAtom<V>, v: V) => void;\n    }, newValue: Value) => void | Promise<void>;\n  },\n): WritableAtom<Value | null>;\n\nexport function selector<Value>(\n  options: {\n    key: string;\n    get: (arg: {\n      get: <V>(a: Atom<V>) => V;\n    }) => Value | Promise<Value>;\n  },\n): Atom<Value | null>;\n\nexport function selector(options: unknown) {\n  return deriveAtom(options as Parameters<typeof deriveAtom>[0]);\n}\n"],"names":["warningObject","Proxy","get","Error","apply","initialState","values","Map","dependents","DispatchContext","createContext","StateContext","Provider","children","useReducer","prevState","action","atom","update","currSuspendable","currState","dirty","inReducer","addDependents","deps","forEach","dependent","currSet","Set","has","set","add","getSuspendable","suspendable","nextValue","a","push","s","value","Promise","currValue","promise","then","v","dispatch","type","promises","map","dep","_currState$values$get","filter","x","length","all","nextSuspendable","_currState$values$get2","updateDependents","size","setValue","initAtom","React","createAtom","options","arg","newValue","deriveAtom","default","useAtom","useContext","useContextSelector","useCallback","state","setAtomState","isWritable","useEffect","undefined","useAtomValue","useAtomUpdate"],"mappings":"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"}